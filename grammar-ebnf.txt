(* Attempt to put the Fountain syntax into an actual EBNF grammar, trying to err on the side of lenience. This version requires infinite lookahead.  *)

fountain_screenplay = { empty_line }, cover_page, script_content ;

cover_page = { cover_key, optional_spaces, ':', optional_spaces, cover_value } ;

cover_key = "Title" | "Credit" | "Author" | "Source" | "Draft date" | "Contact" ;

cover_value = single_value | multi_value ;

single_value = non_newline, { non_newline }, newline ;

multi_value = newline, indented_value { indented_value } ;

indented_value = spaces, non_newline, { non_newline }, newline ;

script_content = (start_of_file | empty_line, { empty_line }), { section_indicator | master_scene | synopse } ;

section_indicator = '#', { '#' }, spaces, non_newline, { non_newline }, newline, empty_line ;

master_scene = master_scene_heading, scene_content ;

master_scene_heading =

boneyard = "/*", { character - '*' | '*', { end_of_file | character - '/' } }, (end_of_file | "*/")

uppercase_letter = 'A' |  'B' |  'C' |  'D' |  'E' |  'F' |  'G' |  'H' |  'I' |  'J' |
                   'K' |  'L' |  'M' |  'N' |  'O' |  'P' |  'Q' |  'R' |  'S' |  'T' |
                   'U' |  'V' |  'W' |  'X' |  'Y' |  'Z'

lowercase_letter = 'a' |  'b' |  'c' |  'd' |  'e' |  'f' |  'g' |  'h' |  'i' |  'j' |
                   'k' |  'l' |  'm' |  'n' |  'o' |  'p' |  'q' |  'r' |  's' |  't' |
                   'u' |  'v' |  'w' |  'x' |  'y' |  'z'

letter = uppercase_letter | lowercase_letter

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

alphanumeric = letter | digit

space = ' ' | '\t' | 

optional_spaces = { space }

spaces = space, optional_spaces

newline = ('\r', ['\n'])
        | ('\n', ['\r'])
        | "\v"
        | "\f"
        | "\x0085"
        | "\x2028"
        | "\x2029" ;

empty_line = [ space ], newline

character = ? all Unicode characters ?

non_newline = (character - newline)

start_of_file = ? start of file ?

end_of_file = ? end of file ?
